// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: query.sql

package decisionlogs

import (
	"context"
	"time"
)

const createDecisionLog = `-- name: CreateDecisionLog :one
INSERT INTO decision_logs (
  decision_id, path, input, revision_id, result, timestamp
) VALUES (
  ?, ?, ?, ?, ?, ?
)
RETURNING decision_id, path, input, revision_id, result, timestamp
`

type CreateDecisionLogParams struct {
	DecisionID string    `json:"decision_id"`
	Path       string    `json:"path"`
	Input      string    `json:"input"`
	RevisionID *string   `json:"revision_id"`
	Result     string    `json:"result"`
	Timestamp  time.Time `json:"timestamp"`
}

func (q *Queries) CreateDecisionLog(ctx context.Context, arg CreateDecisionLogParams) (DecisionLog, error) {
	row := q.db.QueryRowContext(ctx, createDecisionLog,
		arg.DecisionID,
		arg.Path,
		arg.Input,
		arg.RevisionID,
		arg.Result,
		arg.Timestamp,
	)
	var i DecisionLog
	err := row.Scan(
		&i.DecisionID,
		&i.Path,
		&i.Input,
		&i.RevisionID,
		&i.Result,
		&i.Timestamp,
	)
	return i, err
}

const getDecisionLog = `-- name: GetDecisionLog :one
SELECT decision_id, path, input, revision_id, result, timestamp FROM decision_logs
WHERE decision_id = ? LIMIT 1
`

func (q *Queries) GetDecisionLog(ctx context.Context, decisionID string) (DecisionLog, error) {
	row := q.db.QueryRowContext(ctx, getDecisionLog, decisionID)
	var i DecisionLog
	err := row.Scan(
		&i.DecisionID,
		&i.Path,
		&i.Input,
		&i.RevisionID,
		&i.Result,
		&i.Timestamp,
	)
	return i, err
}

const listDecisionLogs = `-- name: ListDecisionLogs :many
SELECT decision_id, path, input, revision_id, result, timestamp FROM decision_logs
ORDER BY "timestamp" DESC
`

func (q *Queries) ListDecisionLogs(ctx context.Context) ([]DecisionLog, error) {
	rows, err := q.db.QueryContext(ctx, listDecisionLogs)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DecisionLog
	for rows.Next() {
		var i DecisionLog
		if err := rows.Scan(
			&i.DecisionID,
			&i.Path,
			&i.Input,
			&i.RevisionID,
			&i.Result,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const listDecisionLogsSearch = `-- name: ListDecisionLogsSearch :many
SELECT decision_id, path, input, revision_id, result, timestamp FROM decision_logs
WHERE decision_id LIKE ? OR path LIKE ? OR input LIKE ? OR result LIKE ?
ORDER BY "timestamp" DESC
`

type ListDecisionLogsSearchParams struct {
	DecisionID string `json:"decision_id"`
	Path       string `json:"path"`
	Input      string `json:"input"`
	Result     string `json:"result"`
}

func (q *Queries) ListDecisionLogsSearch(ctx context.Context, arg ListDecisionLogsSearchParams) ([]DecisionLog, error) {
	rows, err := q.db.QueryContext(ctx, listDecisionLogsSearch,
		arg.DecisionID,
		arg.Path,
		arg.Input,
		arg.Result,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []DecisionLog
	for rows.Next() {
		var i DecisionLog
		if err := rows.Scan(
			&i.DecisionID,
			&i.Path,
			&i.Input,
			&i.RevisionID,
			&i.Result,
			&i.Timestamp,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
